# Am9511A APU Module

The Am9511 APU is a complete, high performance, complex arithmetic processor contained within a single Large Scale Integration device. It is designed to enhance the number manipulation capability of a wide variety of processor systems. It includes not only floating-point operations but fixed-point as well; not only basic add, subtract, multiply, and divide operations, but a group of transcendental derived functions plus control and format conversion commands as well.

The first Large Scale Integrated single-chip floating point processors available commercially were introduced by Advanced Micro Devices. AMD introduced the Am9511 Arithmetic Processor in 1977, and the Am9512 Floating Point Processor in 1979.

![Am9511A APU Module](https://github.com/RC2014Z80/RC2014/blob/master/Hardware/APU%20RC2014/apu.jpg)

 Intel licensed the Am9511A from AMD and released it to the market as the 8231A APU, before their 8087 FPU was available.

![8231A APU Module](https://github.com/RC2014Z80/RC2014/blob/master/Hardware/APU%20RC2014/8231A.jpg)

All transfers, including operand, result, status, and command information, take place over an 8-bit bidirectional data bus. Operands are pushed onto an internal stack and a command is issued to perform operations on the data in the stack. Results are then available to be retrieved from the stack, or additional commands may be entered operating on the intermediate results.

Although the external data interface is 8-bits wide, the Am9511A internally is a 16-bit micro-programmed, stack-orientated floating point machine. The Am9511A stack can hold 4 32-bit floating point or long numbers, or 8 16-bit integer numbers. Single operand functions are performed on the Top of Stack. Two operand functions are performed with the Top of Stack acting upon the Next on Stack.

# Description

The Am9511A APU module is designed to work with the RC2014 Standard Bus and optionally with the RC2014 Extended Bus. Supporting logic is provided to ensure that the Am9511A APU is adapted to the RC2014 system clock, and to the Z80 control signals.

The Am9511A requires both +5V and +12V power supplies. To obtain +12V a switch-mode boost converter is provided. Consumption of between 50mA and 100mA from both +5V and +12 V supplies is typical, and the device packaging (24-pin ceramic DIL) is designed to dissipate up to 2W. It is normal for the Am9511A to operate __HOT TO TOUCH__ and the APU Module is constructed with 4-layers and complete Vcc and GND layers to enable rapid heat sinking into the PCB.

The Am9511A-1DC device operates at a maximum of 3MHz. Therefore to operate successfully with the RC2014 7.3728MHz system clock a 3:1 reduction of the clocking for the APU is required. A 50% duty 1/3 rate circuit has been constructed from two D flip-flops and a JK flip-flop, and several NOR gates.

![APU Module Schematic](https://github.com/RC2014Z80/RC2014/blob/master/Hardware/APU%20RC2014/apu_sch.png)

The device select is generated by an '138 3-line to 8-line decoder, which also allows the selection of multiple addresses for the APU Module base address. The module uses two consecutive addresses, and the `A0` address line discriminates between data and status/command addresses.

The APU Module `/WR` and `/RD` lines are generated from a '139 2-line to 4-line decoder. As the Am9511A requires 30ns of valid device select following `/WR` this decoding of `/IORQ` and `/WR` is required to be separate to the device select decoding.

Every access to the Am9511A APU triggers activity on its `/PAUSE` line which is connected to the Z80 `/WAIT` line. This ensures that the Z80 timing is aligned with the APU timing. If the RC2014 Enhanced Bus is not being used the __WAIT__ jumper __must be closed__ to bring the signal to the __USER1__ pin on the RC2014 Standard Bus. A similar connection __must be made__ on the Z80 CPU Module.

The Am9511A can operated in "demand wait", "polled", "interrupt", or "DMA" modes. Firmware and libraries developed for the APU Module support a blend of "demand wait" and "polled" mode access to the APU. A connection for the Z80 `/NMI` is present, but the "interrupt" mode and __NMI__ should not be used for normal (provided firmware or library) operation.

# Assembly Guide

This guide assumes you are familiar with assembling circuit boards, soldering, and cleaning. If not, it is recommended you read some of the guides on the Internet before continuing.

Before assembling it is worth visually inspecting the circuit board for anything that looks out of place, such as mechanical damage or apparent manufacturing defects. The PCB should look similar to the below image, although it may be coloured blue.

![APU Module PCB](https://github.com/RC2014Z80/RC2014/blob/master/Hardware/APU%20RC2014/apu_pcb.jpg)

## Passive Devices

To assemble the Am9511A APU Module, start with the two resistors. They will be 10k Ohm, although any value from 2.2k Ohm to 15k Ohm will work successfully. Locate them in the two positions indicated. They are not polarised.

![APU Module Resistors](https://github.com/RC2014Z80/RC2014/blob/master/Hardware/APU%20RC2014/apu_resistor.png)

Then assemble the __4__ diodes. Note that the diodes are polarised. The black band should be at the top of the board. Locate the diodes in the positions indicated.

__OPTIONAL__ Connecting a 200pF capacitor across the `/WAIT` line diode (i.e. in parallel) speeds up recovery of this line which, in turn, speeds up resumption of the CPU processing as soon as the APU releases the `/WAIT` signal. Adding this capacitance positively impacts benchmarking, so it is a highly recommended optional addition.

![APU Module Diodes](https://github.com/RC2014Z80/RC2014/blob/master/Hardware/APU%20RC2014/apu_diode.png)

__Do not__ place a diode in the NMI diode location at this stage (or perhaps ever). _Advanced use only_.

![APU Module NMI Diode](https://github.com/RC2014Z80/RC2014/blob/master/Hardware/APU%20RC2014/apu_nmi.png)

Now insert the 7 capacitors, and located them as indicated. They are 100nF and there is only one type. They are not polarised.

![APU Module Capacitors](https://github.com/RC2014Z80/RC2014/blob/master/Hardware/APU%20RC2014/apu_capacitor.png)

Now solder the Address jumper pins, as indicated. The bridge can be inserted into the default address of `0x42`. If you intend to use only 1 APU Module per RC2014 system, the jumper pins could be omitted and a simple solder bridge can be used instead.

![APU Address Pins](https://github.com/RC2014Z80/RC2014/blob/master/Hardware/APU%20RC2014/apu_addresses.png)

Now insert either a 40x pin RC2014 Standard Bus pin header, or an Enhanced Bus pin header, depending on your planned use. The header should be soldered neatly. If using the Enhanced Bus ensure that a minimum of solder is used so that it does not unintentionally bridge to the Standard Bus pins.

If you are using the RC2014 Standard Bus the __WAIT__ jumper needs to be closed to connect __USER1__ pin. A similar connection needs to be completed on your CPU Module, for [example here](http://blog.tynemouthsoftware.co.uk/2017/08/z80-cpu-clock-and-reset-module-for-RC2014.html).

![APU Module WAIT](https://github.com/RC2014Z80/RC2014/blob/master/Hardware/APU%20RC2014/apu_wait.png)

When complete the __WAIT__ bridge looks like this.

![APU Module WAIT Bridge](https://github.com/RC2014Z80/RC2014/blob/master/Hardware/APU%20RC2014/apu_wait.jpg)

## Active Devices

The [Pololu U3V12F12](https://www.pololu.com/product/2117) boost converter PCB can be laid directly onto the APU Module PCB. The mounting pins form a connection between the two PCBs. There is no need to "stand-off" the boost converter PCB from the APU Module PCB. The boost converter can only be installed one way. When the pins have been soldered on both sides, they can be trimmed short back and front.

![Pololu U3V12F12](https://github.com/RC2014Z80/RC2014/blob/master/Hardware/APU%20RC2014/0J4328.600x480.jpg)

As an alternative, the [Pololu S10V2F12](https://www.pololu.com/product/2096) buck/boost converter can be used. It can be mounted flipped over, [as shown here](https://www.tindie.com/products/semachthemonkey/rc2014-am9511a-apu-arithmetic-processor/). Or, perhaps more neatly, it can be mounted to the rear of the PCB and laid directly onto the APU Module PCB. In either case the SHDN pin shall remain unconnected.

Depending on your level of confidence and competence you can choose to assemble the APU Module with or without device sockets. Either way, ensure that the device numbers are identical to the numbers printed on each device outline. Ensure that the device orientation is the same as on the PCB. Double check orientation by reading the text on the devices and matching to what you can see on this completed APU Module, below.

![Am9511A APU Module](https://github.com/RC2014Z80/RC2014/blob/master/Hardware/APU%20RC2014/apu.jpg)

The Am9511A device benefits from being soldered directly to the board, because of the enhanced cooling effect of the PCB internal copper layers. However, in several years of operating Am9511A devices in sockets I have not experienced a failure, due to heat or otherwise.

## Final Inspection

Remove any solder ‘splats’ with a brush, such as an old toothbrush. Visually inspect the soldering for dry joints and shorts. Clean the flux off with suitable cleaning materials. And, visually inspect again to ensure that there are no solder bridges, particularly on the Standard Bus and Enhanced Bus connections.

# Printed Circuit Board

The Am9511A APU Module PCB was designed using Eagle v6.6. The Gerbers generated by Eagle, together with the Eagle source files are [attached](https://github.com/RC2014Z80/RC2014/blob/master/Hardware/APU%20RC2014/apu_apu_module.zip) and are considered to be open hardware.

# Firmware & User Guide

The Am9511A APU Module is a passive bus device and can exist in any RC2014 system without impacting normal operation. It has a very narrow address range, and responds only to its base address (as set in the jumpers) and one address higher (e.g. the default addresses `0x42` and `0x43`). It can be available to accelerate arithmetic calculations as required.

Several methods of using the Am9511A APU Module exist. As a base platform a specific version of Microsoft Basic has been created which integrates use of the APU into the Basic language.

Also, the Z88DK development platform includes Am9511A APU drivers and floating point library to support the use of the Am9511A APU within C code or assembly code, on demand. Code generated by the Z88DK development platform can be loaded into the RC2014 using optionally the APU specific MS Basic (in Intel HEX format), CP/M (using XMODEM or otherwise), or other Intel HEX program loaders.

## RC2014/APU MS BASIC v4.7

[This ROM](https://github.com/feilipu/NASCOM_BASIC_4.7/tree/master/rc2014_NascomBasic32k_AM9511) works with the __Mini__, __Micro__, and __Classic__ versions of the RC2014, with 32k of RAM. This ROM supports the Am9511A APU Module, and provides the capability to upload and run C or assembly programs from within MS Basic.

The APU Module also works with the __Classic__ version of the RC2014 together using the [8085 CPU Module](https://www.tindie.com/products/feilipu/8085-cpu-module-pcb/), using [this ROM](https://github.com/feilipu/NASCOM_BASIC_4.7/tree/master/rc2014_NascomBasic32k_8085_AM9511).

ACIA 6850 interrupt driven serial I/O to run modified Microsoft Basic 4.7. Full input and output buffering with incoming data hardware handshaking. Handshake shows full before the buffer is totally filled to allow run-on from the sender. Transmit and receive are interrupt driven, and are fast.

Receive buffer is 255 bytes, to allow efficient pasting of Basic into the editor. The Transmit buffer is 31 bytes.

Also, this ROM provides both Intel HEX loading functions and an `RST`, `INT0`, and `NMI` RAM JumP Table, starting at `0x8000`. This allows you to upload Assembly or compiled C programs, and then run them as described below.

```sh
RC2014/APU - MS Basic Loader
z88dk - feilipu

Cold | Warm start (C|W) ? C

Memory top?
Z80 BASIC Ver 4.7c - APU
Copyright (C) 1978 by Microsoft
31948 Bytes free

Ok

```

The goal of this extension to standard MS Basic is to load an arbitrary program in Intel HEX format into an arbitrary location in the Z80 address space, and allow you to start and use your program from MS Basic. Your program can be created in assembler, or in C, provided the code is available in Intel HEX format.

There are are several stages to this process.

1. At the Basic interpreter type `HLOAD`, then the command will initiate and look for your program's Intel HEX formatted information on the serial interface.
2. Once the final line of the HEX code is read into memory, `HLOAD` will return to Microsoft Basic with `ok`.
3. Start the new arbitrary program from Basic by entering the`USR(x)` command.

The `HLOAD` program can be exited without uploading a valid file by typing `:` followed by `CR CR CR CR CR CR`, or any other character.

The top of Basic memory can be readjusted by using the `RESET` function, when required. `RESET` is functionally equivalent to a cold start.

### Benchmark - Basic

Basic is interpreted from tokens derived from the program text entered on the Basic command line. Because each token must be read from memory, and then matched against a function before it can be called, and because mathematical precedence rules must be followed, there is a substantial overhead in generating floating point instructions within Basic. The overhead is such that the rate of APU commands generated is not sufficient to provide a substantial performance improvement within Basic. However there is still a small 15% performance gain to be had, as demonstrated below.


_Benchmark Mandelbrot `colour.bas` - MS Basic 4.7 - omitted program spaces_

- Searle  Std       - 4.7b  11'46"  - 100%<br>
- feilipu Z80+APU   - 4.7c   9'44"  -  83% (with 200pF `/WAIT` capacitor).<br>


## Z88DK Am9511 Floating Point Library

A complete guide is available in the [RC2014 Wiki, using Z88DK](https://github.com/RC2014Z80/RC2014/wiki/Using-Z88DK). In the wiki the section on Floating Point refers to the `math32` library. To use the Am9511A APU library for floating point calculations, the only difference is that the linkage `--am9511` should be used instead of the `--math32`. A complete [guide to the __am9511__ floating point library](https://github.com/z88dk/z88dk/blob/master/libsrc/_DEVELOPMENT/math/float/am9511/readme.md) is available.


### Benchmark - C

Compiled C programs provide the maximum usage of the APU Module, and depending on the [specific benchmark examined](https://github.com/z88dk/z88dk/blob/master/libsrc/_DEVELOPMENT/math/float/am9511/readme.md#execution-speed), between a __2x__ and __5x__ performance increase over software floating point should be expected.


# Notes

- Not for use in military, aerospace, or nuclear research.
- The product contains small parts and is not suitable for young children.
- This product is designed for hobby use and is not suitable for industrial, commercial or safety-critical applications.
